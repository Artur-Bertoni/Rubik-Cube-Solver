package domain.problems;

import domain.Cube;
import domain.Status;
import domain.searches.SearchNode;

import java.util.ArrayList;

/**
 * Represents the chosen problem, must be chosen following the search strategy to be applied
 */
public class Problem {

    private final Status start;

    public Problem(Status start) {
        this.start = start;
    }

    public Problem(Cube actual) {
        start = new Status(actual, "***");
    }


    public Status getStart() {
        return start;
    }

    /**
     * Successors to that search node, that is, all search nodes that can be generated by applying cube operations
     */
    public ArrayList<SearchNode> successors(SearchNode e) {
        ArrayList<SearchNode> r = new ArrayList<>();
        ArrayList<Status> successorStatuses = getSuccessorStatus(e.getEstado());
        for (Status status : successorStatuses) {
            r.add(new SearchNode(e, status, e.getDepth() + 1, e.getValue() + 1));
        }
        return r;
    }

    /**
     * Successor states of a given state
     */
    public ArrayList<Status> getSuccessorStatus(Status e) {
        Cube current = e.getCurrent();
        Cube c;
        ArrayList<Status> r = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            c = (Cube) current.clone();
            c.X(i);
            r.add(new Status(c, "X" + i));

            c = (Cube) current.clone();
            c.Y(i);
            r.add(new Status(c, "Y" + i));

            c = (Cube) current.clone();
            c.Z(i);
            r.add(new Status(c, "Z" + i));
        }
        return r;
    }

    /**
     * Verify that the solution has been reached
     */
    public boolean objectiveTest(Status e) {
        return e.getCurrent().equals(e.getReach());
    }
}
