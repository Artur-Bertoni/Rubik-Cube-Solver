package domain.problems;

import domain.Cube;
import domain.Status;
import domain.searches.SearchNode;

import java.util.ArrayList;

/**
 * Represents the chosen problem, must be chosen following the search strategy to be applied
 */
public class Problem {

    private final Status start;

    public Problem(Cube actual) {
        start = new Status(actual, "***");
    }


    public Status getStart() {
        return start;
    }

    /**
     * Successors to that search node, that is, all search nodes that can be generated by applying cube operations
     */
    public ArrayList<SearchNode> successors(SearchNode e) {
        ArrayList<SearchNode> r = new ArrayList<>();
        ArrayList<Status> successorStatuses = getSuccessorStatus(e.getCurrent());
        for (Status status : successorStatuses) {
            r.add(new SearchNode(e, status, e.getDepth() + 1, e.getValue() + 1));
        }
        return r;
    }

    /**
     * Successor status of a given status
     */
    public ArrayList<Status> getSuccessorStatus(Status e) {
        Cube current = e.getCurrent();
        Cube c;
        ArrayList<Status> r = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            c = (Cube) current.clone();
            c.moveARowToTheRight(i);
            r.add(new Status(c, "R(" + i + ")tR"));

            c = (Cube) current.clone();
            c.moveOneColumnDown(i);
            r.add(new Status(c, "C(" + i + ")tD"));

            c = (Cube) current.clone();
            c.rotate(i);
            r.add(new Status(c, "F(" + i + ")tR"));
        }
        return r;
    }

    /**
     * Verify that the solution has been reached
     */
    public boolean objectiveTest(Status e) {
        return e.getCurrent().equals(e.getReach());
    }

    protected int heuristics(Status e) {
        return e.getCurrent().getValueDistanceManhattan() - e.getCurrent().completed();
    }
}
